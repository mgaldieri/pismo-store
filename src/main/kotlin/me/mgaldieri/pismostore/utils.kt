package me.mgaldieri.pismostore

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import me.mgaldieri.pismostore.dao.CartDAO
import me.mgaldieri.pismostore.dao.PaymentDAO
import me.mgaldieri.pismostore.models.*
import org.sql2o.Connection
import spark.Response

fun abort(resp: Response, message: String, httpCode: Int) : String {
    val error = ErrorMessage(
            "Server Error",
            "0000",
            httpCode,
            message
    )
    val responseData = ResponseData(null, error)

    val mapper = jacksonObjectMapper()
    val jsonString = mapper.writeValueAsString(responseData)

    resp.status(httpCode)
    resp.type("application/json;charset=utf-8")

    return jsonString
}

fun success(resp: Response, data: Any?) : String {
    val responseData = ResponseData(data, null)

    val mapper = jacksonObjectMapper()
    val jsonString = mapper.writeValueAsString(responseData)

    resp.status(200)
    resp.type("application/json;charset=utf-8")

    return jsonString
}

fun buildUserCart(products: HashMap<Int, CartItem>) : Cart? {
    val cart = Cart(products, 0)

    val productIds = products.keys
    if (productIds.size == 0) return cart

    val url = "$WAREHOUSE_URL/vendor/products?filter=${productIds.joinToString(",")}"
    val resp = HTTPHelper.doRequest(url, HttpVerb.GET, null)
    if (resp.error != null) return null

    val whProducts = (resp.data as LinkedHashMap<*, *>)["products"] ?: return null
    var totalPriceCents = 0
    for (whProduct in whProducts as ArrayList<LinkedHashMap<*, *>>) {
        val productId = whProduct["id"] as Int
        val localQty = products[productId]!!.qty
        totalPriceCents += (whProduct["priceCents"] as Int) * localQty
    }
    cart.totalPriceCents = totalPriceCents

    return cart
}

fun chargeUserForCart(user: User, cart: Cart) : ErrorMessage? {
    val error = ErrorMessage("Server error", "0000", 500, "")

    // Check stock for availability
    val productIds = cart.products.keys

    var url = "$WAREHOUSE_URL/vendor/products?filter=${productIds.joinToString(",")}"
    var resp = HTTPHelper.doRequest(url, HttpVerb.GET, null)
    if (resp.error != null) {
        error.httpCode = 502
        error.message = "Bad Gateway"
        return error
    }

    val whProducts = (resp.data as LinkedHashMap<*, *>)["products"] ?: fun() : ErrorMessage {
        error.httpCode = 502
        error.message = "Bad Gateway"
        return error
    }

    for (whProduct in whProducts as ArrayList<LinkedHashMap<*, *>>) {
        val productId = whProduct["id"] as Int
        val productName = whProduct["name"] as String
        val whQty = whProduct["qty"] as Int
        if (cart.products[productId]!!.qty > whQty) {
            error.httpCode = 406
            error.message = "Not enough items in stock for $productName"
            return error
        }
    }

    // Mark products as sold in Warehouse
    val paymentToken = generateSimpleHash()  // Fake token. Real one should be generated by some payment gateway service

    url = "$WAREHOUSE_URL/vendor/products/sell"
    val mapper = jacksonObjectMapper()
    val payload = mapper.createObjectNode()
    payload.put("paymentToken", paymentToken)
    payload.set("products", mapper.valueToTree(cart.products.values))
    resp = HTTPHelper.doRequest(url, HttpVerb.POST, payload)
    if (resp.error != null) {
        error.httpCode = 502
        error.message = "Bad Gateway"
        return error
    }

    // Record successful payment
    val payment = Payment(null, user.id, paymentToken, cart.totalPriceCents!!)
    val (_, s1) = PaymentDAO.save(payment)
    if (!s1) {
        error.httpCode = 500
        error.message = "Error saving payment"
        return error
    }

    // Empty cart
    val (_, s2) = CartDAO.emptyUserCart(user)
    if (!s2) {
        error.httpCode = 500
        error.message = "Error emptying shopping cart"
        return error
    }

    return null
}

fun initDB() {
    val initSQL = object {}.javaClass.getResource("initdb.sql").readText(Charsets.UTF_8)
    val db = DBHelper.getInstance()
    val conn: Connection = db.open() ?: throw RuntimeException("Could not open connection to DB")
    conn.createQuery(initSQL).executeUpdate()
}